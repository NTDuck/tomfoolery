package org.tomfoolery.infrastructures.dataproviders.repositories.hybrid;

import lombok.RequiredArgsConstructor;
import lombok.val;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.signedness.qual.Unsigned;
import org.tomfoolery.core.dataproviders.repositories.abc.BaseRepository;
import org.tomfoolery.core.utils.contracts.ddd.ddd;
import org.tomfoolery.core.utils.dataclasses.common.Page;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import java.util.stream.Collectors;

@RequiredArgsConstructor(staticName = "of")
public class HybridRepository<Entity extends ddd.Entity<EntityId>, EntityId extends ddd.EntityId> implements BaseRepository<Entity, EntityId> {
    private final @NonNull List<BaseRepository<Entity, EntityId>> persistenceRepositories;
    private final @NonNull List<BaseRepository<Entity, EntityId>> retrievalRepositories;

    @Override
    public void save(@NonNull Entity entity) {
        this.persistenceRepositories.parallelStream()
            .forEach(repository -> repository.save(entity));
    }

    @Override
    public void delete(@NonNull EntityId entityId) {
        this.persistenceRepositories.parallelStream()
            .forEach(repository -> repository.delete(entityId));
    }

    @Override
    public @Nullable Entity getById(@NonNull EntityId entityId) {
        val persistedEntity = this.getByIdFromAny(entityId, this.persistenceRepositories);

        if (persistedEntity != null)
            return persistedEntity;

        val retrievedEntity = this.getByIdFromAny(entityId, this.retrievalRepositories);

        if (retrievedEntity != null)
            CompletableFuture.runAsync(() -> this.save(retrievedEntity));

        return retrievedEntity;
    }

    @Override
    public @NonNull List<Entity> show() {
        return this.persistenceRepositories.parallelStream()
            .flatMap(repository -> repository.show().parallelStream())
            .collect(Collectors.toUnmodifiableList());
    }

    @Override
    public boolean contains(@NonNull EntityId entityId) {
        val persistenceContains = this.containsFromAny(entityId, this.persistenceRepositories);

        if (persistenceContains)
            return true;

        val retrievalContains = this.containsFromAny(entityId, this.retrievalRepositories);

        if (retrievalContains) {
            val retrievedEntity = this.applyOnAny(repository -> repository.getById(entityId), this.retrievalRepositories);
            assert retrievedEntity != null;
            CompletableFuture.runAsync(() -> this.save(retrievedEntity));
        }

        return retrievalContains;
    }

    @Override
    public @Nullable Page<Entity> showPaginated(@Unsigned int pageIndex, @Unsigned int maxPageSize) {
        return BaseRepository.super.showPaginated(pageIndex, maxPageSize);
    }

    private @Nullable Entity getByIdFromAny(@NonNull EntityId entityId, @NonNull List<BaseRepository<Entity, EntityId>> repositories) {
        return this.applyOnAny(repository -> repository.getById(entityId), repositories);
    }

    private boolean containsFromAny(@NonNull EntityId entityId, @NonNull List<BaseRepository<Entity, EntityId>> repositories) {
        val contains = this.applyOnAny(repository -> repository.contains(entityId), repositories);

        if (contains == null)
            return false;

        return contains;
    }

    private <T> @Nullable T applyOnAny(@NonNull Function<BaseRepository<Entity, EntityId>, T> mapper, @NonNull List<BaseRepository<Entity, EntityId>> repositories) {
        return repositories.parallelStream()
            .map(mapper)
            .findAny()
            .orElse(null);
    }
}
